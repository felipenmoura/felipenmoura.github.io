<section id="articles-container" class="sect-content">
    <nav id="articles-nav" class="articles-nav">
        <ul>
            <li class="btn center">
                <span class="local art-nav-tbn" title="See all Posts">
                    See all&nbsp; |<!--small>▼</small-->
                </span>
                <span class="art-nav-tbn art-tools" title="Article Tools">
                    &nbsp;&#9881; <!--small>▼</small-->
                </span>
            </li>
            <li class="btn left">
                
                <a class="local art-nav-tbn inactive"
                
                   title="previous: "><< Prev</a>
            </li>
            <li class="btn right">
                
                <a href=""
                   class="local art-nav-tbn inactive"
                
                   title="Next: ">Next >></a>
            </li>
        </ul>
        
        <div class="article-tools">
            <span id="article-tool-bigger" class="art-nav-tbn">A</span>
            <span id="article-tool-smaller" class="art-nav-tbn">A</span>
            <span id="article-tool-contrast" class="art-nav-tbn"></span>
        </div>
    </nav>
    
    <div id="the-article" class="the-article" data-text-size="2">
        <div class="decorator
                    colour-3
                    ">
            <h2>call, bind e apply no JavaScript<em> - parte 2</em></h2>
            <div class="wrapper">
                <img src="http://felipenmoura.org/wp-content/uploads/2014/09/tied-binded.jpg" alt="" title="" />
            </div>
            <span id="article-meta-data">
                Sept 22nd, 2014 : es6, javascript, ecma6, es2015
            </span>
            
            <abs>
                Este post, é uma continuação de outro post, <a href='http://felipenmoura.org/articles/article/call-bind-e-apply-no-javascript-parte-1' title='Call, Bind e Apply no JavaScript (parte 1) - Funções'>mais focado em funções</a>.<br/>Neste, focaremos realmente nos três métodos do título deste artigo, <strong>.call</strong>, <strong>.bind</strong> e <strong>.apply</strong>.<br/><br/>Agora que você já leu sobre <a href='http://felipenmoura.org/articles/hoisting-no-javascript' title='Hoisting no JavaScript' target='_blank'>hoisting</a>, <a href='http://felipenmoura.org/articles/article/escopo-this-e-that/' title='Escopos no JavaScript' target='_blank'>escopos</a>, e como as funções funcionam e podem ser declaradas e executadas na primeira parte deste artigo, podemos abordar esta, que considero ser uma parte um pouco mais avançada do JavaScript.<br/><br/>Estes três métodos estão presentes no <em>prototype</em> de <em>Function</em>, ou seja, toda função terá estes métodos, nativamente.<br/>Uma coisa bacana, também, é que isto funciona igualzinho em nodejs ;)<br/>
            </abs>
            
        </div>

        <div class="wrapper articles-content">
            <article>
                <br/>
<strong>.call()</strong><br/>
<br/>
O método <em>.call</em>, literalmente, "chama" a sua função.<br/>
<br/>
<pre lang="javascript"><br/>
function func1(){<br/>
    return 1;<br/>
}<br/>
<br/>
var func2= function(){<br/>
    return 2;<br/>
}<br/>
<br/>
func1.call(); // 1<br/>
func2.call(); // 2<br/>
<br/>
</pre><br/>
<br/>
A diferença, está nos argumentos(parâmetros) passados a esta função.<br/>
Ela permite que você possa <em>setar</em> qual o escopo daquela função.<br/>
<br/>
<pre lang="javascript"><br/>
// criando uma variável global apenas para demonstração<br/>
window.blah= 1;<br/>
<br/>
// uma função que utiliza o this<br/>
function func1 () {<br/>
    console.log(this.blah);<br/>
}<br/>
<br/>
// um objeto a ser usado como exemplo<br/>
var obj= {<br/>
    blah: 2<br/>
};<br/>
<br/>
func1(); // 1 (vindo do objeto window), escopo atual<br/>
func1.call(obj); // 2 (vindo do objecto obj)<br/>
<br/>
</pre><br/>
<br/>
Além disso, podemos passar parâmetros para aquela função, além do escopo atual.<br/>
<pre lang="javascript"><br/>
<br/>
function func1 (arg1, arg2) {<br/>
    console.log(this.blah, arg1, arg2);<br/>
}<br/>
<br/>
var obj= {<br/>
    blah: "x"<br/>
};<br/>
<br/>
func1.call(obj, "a", 3); // "x", "a", 3<br/>
<br/>
</pre><br/>
<br/>
Um macete interessante, é que por exemplo, ao utilizar o objeto <em>arguments</em>, ele trata-se de uma <em>collection</em>, e não uma <em>Array</em>, por tanto, não tem alguns métodos do prototype de Array, como <em>.forEach</em>, ou <em>.sort</em>.<br/>
Daí, podemos resolver isto usando:<br/>
<br/>
<pre lang="javascript"><br/>
function (){<br/>
    var args= Array.prototype.slice.call(arguments);<br/>
    args.forEach(...);<br/>
}<br/>
</pre><br/>
<br/>
Isto funciona por que o método slice da Array basicamente pega uma "fatia" da array (o this, do ponto de vista do prototype), devolvendo em uma nova Array.<br/>
Neste caso, estamos dizendo para o método slice, que o "this" dele, é na verdade aquela collection, e ele nos devolverá uma nova Array, com a fatia de 0 até o final dela(pois não passamos nenhum outro argumento a ela).<br/>
<br/>
<strong>.apply()</strong><br/>
<br/>
O método apply da função, é parecido com o call, porém, ele recebe uma lista de argumentos, na forma de uma Array, mesmo.<br/>
<br/>
<pre lang="javascript"><br/>
// igual exemplo anterior<br/>
function func1 (arg1, arg2) {<br/>
    console.log(this.blah, arg1, arg2);<br/>
}<br/>
<br/>
var obj= {<br/>
    blah: "x"<br/>
};<br/>
<br/>
// apply está enviando uma Array, com a lista de parâmetros<br/>
func1.apply(obj, ["a", 3]); // "x", "a", 3<br/>
</pre><br/>
<br/>
A principal vantagem é que algumas vezes, queremos apenas repassar os argumentos recebidos em uma função, diretamente para outra, usando o próprio <em>arguments</em>.<br/>
<br/>
<pre lang="javascript"><br/>
function func1(){<br/>
    someOtherFunc.apply(obj, Array.prototype.slice.call(arguments));<br/>
}<br/>
</pre><br/>
<br/>
<strong>.bind()</strong><br/>
<br/>
O bind, funciona um pouco diferente.<br/>
Ele não executará sua função na mesma hora, como o call e o apply, ao contrário disto, ele RETORNARÁ uma nova função, a qual já estará com seu escopo definido.<br/>
<br/>
<br/>
<pre lang="javascript"><br/>
// igual exemplo anterior<br/>
function func1 (arg1, arg2) {<br/>
    console.log(this.blah, arg1, arg2);<br/>
}<br/>
<br/>
var obj= {<br/>
    blah: "x"<br/>
};<br/>
<br/>
// a variável theFunction se tornará a função func1<br/>
// amarrada ao obj.<br/>
var theFunction= func1.bind(obj);<br/>
<br/>
// ao chamar theFunction, o "this" dela já é o obj<br/>
theFunction("a", 123); // "x", "a", 123<br/>
<br/>
</pre><br/>
<br/>
Quando finalmente chamamos a função "theFunction", ela já ligada ao objeto "obj", e então, passamos neste momento os argumentos.<br/>
Uma coisa interessante que vale lembrar, é que o bind, infelizmente, tem uma performance meio pobre! Então, cuidado ao sair usando e abusando dele por aí(em especial em loops)!<br/>
Eis uma alternativa que o pessoal faz:<br/>
<br/>
<pre lang="javascript"><br/>
// igual exemplo anterior<br/>
function func1 (arg1, arg2) {<br/>
    console.log(this.blah, arg1, arg2);<br/>
}<br/>
<br/>
var obj= {<br/>
    blah: "x"<br/>
};<br/>
<br/>
// theFunction recebe, literalmente, uma função, a qual usará<br/>
// o .apply, quando chamada<br/>
var theFunction= function(){<br/>
    func1.apply(obj, Array.prototype.slice.call(arguments));<br/>
};<br/>
<br/>
theFunction("a", 123); // "x", "a", 123<br/>
<br/>
</pre><br/>
<br/>
O resultado produzido é o mesmo, mas ao contrário de utilizar o .bind, estamos utilizando o .apply, passando adiante qualquer parâmetro passado àquela função.<br/>
<br/>
<strong>Finalizando</strong><br/>
<br/>
Uma outra coisa interessante, é que o "this" em uma função, pode ser qualquer coisa...<br/>
<br/>
<pre lang="javascript"><br/>
function func3() {<br/>
    console.log(this);<br/>
}<br/>
<br/>
func3(); // window<br/>
func3.call({ some: "prop" }); // object { some: "prop" }<br/>
func3.call("just a string"); // string "just a string"<br/>
func3.call(123); // number 123<br/>
func3.call(document.body); // object HTMLBodyElement<br/>
<br/>
</pre><br/>
<br/>
O que pode acabar sendo usado em situações como esta:<br/>
<br/>
<pre lang="javascript"><br/>
function calc(val1, val2){<br/>
    console.log(this.max(val1, val2));<br/>
    console.log(this.cos(val2));<br/>
    console.log(this.min(val1, val2));<br/>
    console.log(this.pow(val1, val2));<br/>
}<br/>
<br/>
calc.call(Math, 2, 3); // 3, -0.9899924966004446, 2, 8<br/>
<br/>
</pre><br/>
<br/>
Espero que tenha sido um post útil e bem explicativo! :)<br/>
<br/>
Não deixem de divulgar o post, e dar sua opinião.<br/>

            </article>
        </div>
    </div>
</section>